---
title: "Implementing custom autocomplete in VSCode"
pubDate: "2025-11-18"
description: "Implementing custom autocomplete in VSCode"
tags:
  - development
  - vscode
  - ai
toc: true
heroImage: '../../assets/autocomplete-post.png'
---

# AI Summary

### The Problem
The author, a developer at Mondoo, struggled with GitHub Copilotâ€™s performance when writing MQL (Mondoo Query Language). Because MQL is a niche language, standard LLMs (like Gemini or GPT) often "hallucinate" syntax or provide irrelevant code. While models like Claude Sonnet performed better with guidance, using external tools was clunky and expensive.

### The Solution 
The author developed a custom VSCode extension to improve inline autocomplete for MQL without relying on Copilot's default model.

  - Technical approach: They utilized the vscode.InlineCompletionItemProvider API to inject custom autocomplete suggestions.
  - Context Strategy: Instead of feeding the model the entire massive MQL documentation, the extension dynamically loads "boilerplate patterns" (templates) based on the file's context (e.g., if editing a Linux policy, it loads Linux-specific templates).

### The Outcome

  - Success: The custom extension provides accurate, syntax-compliant MQL code snippets that match the specific patterns required for the job.
  - Limitation: A minor annoyance remains where VSCode forces the default Copilot suggestion to appear first; the user must cycle through suggestions to find the custom, correct one.

# 100% bio keyboard clicks

## Overview

> Note: This post is about VSCode and CoPilot in it.

I went full cycle with the AI tools, from completely vibing whole projects and tools to not using 
AI at all, to using only autocomplete and back. I found out that the sweet spot for me is the 
autocomplete, but the thing with the autocomplete is that sometimes (most of the time) it spits absolute
crap, and sometimes it is really annoying by trying to complete your sentance, for example you are
writing a comment on a function explaining what it does and out of nowhere it will autocomplete some utter trash,  and the problem here is that I start to read it as it appears and I completely lose my thoughts for the function and what I was writing. Now this is getting really annoying, one workaround is to disable CoPilot and enable it via keyboard shortcut:

```
@command:github.copilot.completions.toggle +when:github.copilot.activated
```

> I haven't tried Cursor's autocomplete at the time of writing this.

Alright, so to the main problem that I have (had?), currently I am employed by Mondoo, and on my day to day activities I have to write a lot of MQL (Mondoo Query Language), which is a query language that is created by ...... (you have to guess it). As of now the frontier LLMs are oblivious to this query language, yes they will gaslight you that they know it and everything but then they will produce some utter trash like the following example:

> Note: Gemini 3 (latest and greatest model)

![chatbot](../../assets/custom-ac-chatbot-resp.png)

Me: Oh shit, the post is obsolete now... 

![chatbot2](../../assets/custom-ac-chatbot-resp2.png)
![chatbot2](../../assets/custom-ac-cnspec-shell-err.png)

Me: Why you always lyin'

Now, of course I cannot expect every model to know MQL, some will be better at it simply by being better at 
query languages in general, and some would be bad. Notable mention here is Claude Opus/Sonnet, they are 
"getting" the MQL, and most of the time its correct (if guided properly). A good measure for me was how well the model knew terraform, there seem to be a corelation here.

At first I tried to make it learn the MQL by prompting it the syntaxis and how to write it and for a brief 
time that was sufficient for us, most of the models followed the guide lines and produced "fairly" okayish
MQL, that we had to tweak. I created a benchmark for us where I tested bunch of models.

![heatmap1](../../assets/custom-ac-heatmap.png)

This is one of the heatmaps that I created, I benchmarked the models from simple MQL syntaxis to advanced
queries based on complex requirements. I had this interesting observation for the new resources that we provide, for example if we create some new fields in AWS's provider, I noticed that the LLMs are making better names for them, and I had this idea of LLM generation driven development, which could ease the discovery of the resources by LLM when they don't have them in their training data.

Another benchmark would test the models with tools enabled, with MCP and tools enabled, and with context, tools and MCP. Gemini got the biggest improvement (~60%) with all the things enabled, again not reaching the level of Claude Sonnet but I thought that was interesting.

Now I got a 'somewhat' good MQL generation tooling using the Claude Sonnet 4, but it was clunky, I had to use another tool and copy paste stuff around, it wasn't perfect. Not to mention that at some point it became expensive (using the API) and I was hitting the limits on Claude Code too. I realized that I needed something light, fast and cheap, 

I was always a big fan of the really fast and tiny models that get simple jobs done, I am especially a fan of the fast coding models, right now my favorite is `Grok Code Fast 1` in the CoPilot Chat. I wanted to initially change the autocomplete model of copilot to be this one, but apperantly it is not possible to change the model, because they only have 1 available and thats the `gpt-41-copilot` model, which is a finetuned model specifically created for VSCode. 

Then I thought of the AI extensions that were offering autocomplete, they were doing it via some custom UI code, becuase you cannot meld with the copilot's inline thing, but upon further research I found out that you can actually use the [vscode.InlineCompletionItemProvider](https://www.vscodeapi.com/interfaces/vscode.inlinecompletionitemprovider) to provide other autocompletion items than the initial/default ones that are provided by copilot. Now that is great, but the context that you need for the model to learn MQL is quite big (~10k tokens) and that's without the providers fields, clearly providing it with raw MQL context wasn't the solution. 

Then I thought, what if you provide it with dynamic context based on what you have opened in the Editor, let's say that you are working on some MQL for Linux, the way that MQL works is within a policy file, so you are essentially writing a YAML file with bunch of checks that look like this:

```yaml
  - uid: mondoo-linux-security-permissions-on-all-logfiles-are-configured
    title: Ensure secure permissions on all log files are set
    impact: 80
    mql: |
      files.find(from: "/var/log", type: "file").list {
        path
        permissions.group_writeable == false
        permissions.group_executable == false
        permissions.other_readable == false
        permissions.other_writeable == false
        permissions.other_executable == false
      }
```

Now if you delete the MQL and use the default autocomplete for VScode you will get something like this:

![autocomplete](../../assets/custom-ac-ac-def.png)

Already far from what we want to have there, so I thought what if instead of providing the whole MQL context, I provide the boilerplate code for certain checks, you see we don't always write "unique" queries, more or less we are reusing queries that we already wrote, so I wanted to create a `store` that will contain all the boilerplate MQL checks that I want to have and then provide them to the autocomplete as context.

The problem that arised here is that we would end up with a lot of context again that would mess up the generation part. So I needed a dynamic selector of context, now this part is quite simple and quite naive but I simply got the filename and keywords from the policy itself, like the policy name then I used that to load the patterns(boilerplate) that I need, for example I would have the following pattern in my store:

```yaml
  - id: linux-file-permissions-template
    platform: linux
    description: Ensure a file exists and has specific ownership and permission settings
    variables:
      - name: filePath
        type: string
        description: Absolute path to the file to check
      - name: owner
        type: string
        description: Expected owner username of the file
      - name: group
        type: string
        description: Expected group name of the file
      - name: userReadable
        type: boolean
        description: Whether the file should be readable by the owner
      - name: userWriteable
        type: boolean
        description: Whether the file should be writeable by the owner
      - name: userExecutable
        type: boolean
        description: Whether the file should be executable by the owner
      - name: groupReadable
        type: boolean
        description: Whether the file should be readable by the group
      - name: groupWriteable
        type: boolean
        description: Whether the file should be writeable by the group
      - name: groupExecutable
        type: boolean
        description: Whether the file should be executable by the group
      - name: otherReadable
        type: boolean
        description: Whether the file should be readable by others
      - name: otherWriteable
        type: boolean
        description: Whether the file should be writeable by others
      - name: otherExecutable
        type: boolean
        description: Whether the file should be executable by others
    template: |
      [{filePath}].where(file(_).exists) {
        file(_) {
          user.name == '{owner}'
          group.name == '{group}'
          permissions.user_readable == {userReadable}
          permissions.user_writeable == {userWriteable}
          permissions.user_executable == {userExecutable}
          permissions.group_readable == {groupReadable}
          permissions.group_writeable == {groupWriteable}
          permissions.group_executable == {groupExecutable}
          permissions.other_readable == {otherReadable}
          permissions.other_writeable == {otherWriteable}
          permissions.other_executable == {otherExecutable}
        }
      }
    context: |
      Use this template to assert that a file exists and has the specified owner, group, and permission settings. Replace each placeholder with the appropriate value for your use case.
    examples:
      - description: Ensure /etc/issue.net is owned by root:root and has permissions 644
        mql: |
          ["/etc/issue.net"].where(file(_).exists) {
            file(_) {
              user.name == 'root'
              group.name == 'root'
              permissions.user_readable
              permissions.user_writeable
              permissions.user_executable == false
              permissions.group_readable
              permissions.group_writeable == false
              permissions.group_executable == false
              permissions.other_readable
              permissions.other_writeable == false
              permissions.other_executable == false
            }
          }
```

Now this will be provided to the autocomplete everytime when you work on a Linux Platform checks, plus bunch of other patterns that I created based on the `platform` field, this isn't ideal again because I might end up with so much patterns that would mess up the context again, but I have other improvements in mind like another filter for patterns based on the resources that it needs to use.

Anyway, after the implementation and the extension being enabled:

![autocomplete](../../assets/custom-ac-ac-with-ext.jpg.png)

Much better, and actually right what we want from the generation. As you see there is a specific syntax that we want to use for these type of checks too.

But copilot has a caveat that I couldn't fix intially and I still can't, probably there isn't a solution for it yet. You cannot alter the whole autocomplete you have to cycle through the provided items, and the first (and sometimes even the second) one is always by the default copilot autocomplete, so the first item is always some trash and you have to wait for the second autocomplete to load.

Anyway, I thought that this little project was worth a blog post and may provide some ideas for you how to use these APIs to build something custom for yourself. I hope that I was helpful enough to provide enough details, if you have questions or anything really you can email me at `me{@]dganev.com`.