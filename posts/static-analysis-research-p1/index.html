<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Static Analysis Research - Windows PE | 0x73796C31</title><meta name=keywords content><meta name=description content="Overview Recently, I decided do delve a little bit more into static analysis, something beyond just running strings on a binary and getting the ASCII characters that are printable. I decided to take a deep look at how FLOSS is working and possibly recreate some of its functionality in my own tool.
Before reading further, I want you to know that this post is about research I did on static analysis."><meta name=author content="Dimitar Ganev"><link rel=canonical href=https://sy1.sh/posts/static-analysis-research-p1/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sy1.sh/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sy1.sh/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sy1.sh/favicon-32x32.png><link rel=apple-touch-icon href=https://sy1.sh/apple-touch-icon.png><link rel=mask-icon href=https://sy1.sh/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Static Analysis Research - Windows PE"><meta property="og:description" content="Overview Recently, I decided do delve a little bit more into static analysis, something beyond just running strings on a binary and getting the ASCII characters that are printable. I decided to take a deep look at how FLOSS is working and possibly recreate some of its functionality in my own tool.
Before reading further, I want you to know that this post is about research I did on static analysis."><meta property="og:type" content="article"><meta property="og:url" content="https://sy1.sh/posts/static-analysis-research-p1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-06T09:44:47+03:00"><meta property="article:modified_time" content="2023-01-06T09:44:47+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Static Analysis Research - Windows PE"><meta name=twitter:description content="Overview Recently, I decided do delve a little bit more into static analysis, something beyond just running strings on a binary and getting the ASCII characters that are printable. I decided to take a deep look at how FLOSS is working and possibly recreate some of its functionality in my own tool.
Before reading further, I want you to know that this post is about research I did on static analysis."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://sy1.sh/posts/"},{"@type":"ListItem","position":3,"name":"Static Analysis Research - Windows PE","item":"https://sy1.sh/posts/static-analysis-research-p1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Static Analysis Research - Windows PE","name":"Static Analysis Research - Windows PE","description":"Overview Recently, I decided do delve a little bit more into static analysis, something beyond just running strings on a binary and getting the ASCII characters that are printable. I decided to take a deep look at how FLOSS is working and possibly recreate some of its functionality in my own tool.\nBefore reading further, I want you to know that this post is about research I did on static analysis.","keywords":[],"articleBody":"Overview Recently, I decided do delve a little bit more into static analysis, something beyond just running strings on a binary and getting the ASCII characters that are printable. I decided to take a deep look at how FLOSS is working and possibly recreate some of its functionality in my own tool.\nBefore reading further, I want you to know that this post is about research I did on static analysis. There is nothing new here - no new tools or features are being discovered. Everything that I talk about already exists in other tools. A big part of this research uses the OpenAI Chat GPT. I made sure to fact-check the information provided here, as the GPT can sometimes produce misleading output.\nMy research focuses on Windows Portable Executable (PE) files because they are the most common type. Therefore, we’ll start by exploring how these files operate.\nKeywords RVA (Relative Virtual Address) - the virtual address of an object from the file once it is loaded into memory, minus the base address of the file image. IDT (Import Directory Table) - is a data structure in a Portable Executable (PE) file that stores information about dynamic-link libraries (DLLs) that the file depends on and the functions that the file imports from those DLLs. ILT - is a data structure in a Portable Executable (PE) file that stores the addresses of imported functions in the executable or library. IAT (Import Address Table) - can be the same with ILT, however when a file is being loaded into memory the loader will overwrite the addresses of the IAT with their new memory address locations. DEP (Data Execution Prevention) - is a security feature that is designed to prevent code from being executed in certain areas of memory where it is not supposed to be executed. doc ASLR (Address Space Layout Randomization) - is a security feature that randomizes the memory locations of certain parts of a program or operating system, making it more difficult for attackers to predict or control where certain code or data is located in memory. wiki Windows Portable Executable (PE) An executable is a set of binary data that contains instructions for the operating system to execute when the program is loaded into memory. Let’s examine how we can manually parse a Portable Executable (PE) file by reading and interpreting the bytes it contains. To do this, we must carefully review the binary data in the PE file and try to make sense of it.\nThe term image refers to the contents of a file when it is loaded into memory. You will encounter this term frequently in the explanations below.\nDOS Header The first 64 bytes of a binary file represent the DOS header, which is included for backwards compatibility and does not directly affect the functioning of the Portable Executable (PE). These 64 bytes contain information such as the number of pages in the file, the number of relocations, the checksum, OEM identifiers, and reserved words. The last 4 bytes of the DOS header, e_lfanew, contain the offset or address of the new PE header in modern Windows applications.\nThe first two bytes of an executable file, 4D 5A which translates to MZ in ASCII, serve as an indicator that the file is an executable intended for use on a Windows operating system.\nWhy 4D 5A? DOS Stub / Rich Header Following the first 64 bytes is the DOS Stub, a small program that displays an error message on systems that are not compatible with MS-DOS. This is a legacy feature dating back to the early days of Windows, when the operating system was built on top of MS-DOS.\nThe Rich Header, on the other hand, is not a required or standard part of the Portable Executable (PE) file format. It contains metadata about the compiler or packer that was used to create the executable and may provide additional information about the file. The magic number for the Rich Header is 52 69 63 68, which translates to Rich in ASCII.\nThe Rich Header information is encrypted using the XOR cipher, which can be easily decrypted using the 4 bytes immediately following the Rich ASCII which is the key.\nTo decrypt the rest of the header, we must run the XOR decipher on the file and unmask the value 44 61 6E 53, which translates to “DanS” in ASCII. This marks the beginning of the Rich Header, which is then followed by 3 0s after deciphering.\nWith this information, we can determine the start and end of the Rich Header and parse it accordingly.\nThe header can contain data about:\nCompiler and build environment information Timestamps Checksums Other metadata The Rich Header is a very interesting topic that I would like to write more about, until then you can read the following articles.\nVB2019 paper: Rich Headers: leveraging this mysterious artifact of the PE format The devil’s in the Rich header NT Headers (New Technology) If we follow the offset indicated in the last two bytes of the DOS header, we will reach the new PE headers (also known as NT headers). These headers are identified by the 4-byte magic number 50 45 00 00, which translates to PE.. in ASCII. This magic number is used to distinguish the PE headers from other types of headers.\nThe structure of the _IMAGE_NT_HEADERS64:\ntypedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; The structure of _IMAGE_FILE_HEADER:\ntypedef struct _IMAGE_FILE_HEADER { WORD Machine; // Predefined value [IMAGE_FILE_MACHINE_I386 or IMAGE_FILE_MACHINE_AMD64] WORD NumberOfSections; DWORD TimeDateStamp; // Timestamp of which the executable was compiled or linked DWORD PointerToSymbolTable; // The offset to the COFF Symbol Table DWORD NumberOfSymbols; // The number of symbols in the COFF Header WORD SizeOfOptionalHeader; WORD Characteristics; // https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; What is COFF? The structure of _IMAGE_OPTIONAL_HEADER, this structure is “optional” but in fact most of the PE files contains this header.\ntypedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; // .text section size DWORD SizeOfInitializedData; // .data section size DWORD SizeOfUninitializedData; // .bss section size DWORD AddressOfEntryPoint; // 0 if a DLL because its optional otherwise it indicates the RVA (Relative Virtual Address) it is used to determine the address of elements within the file (strings, icons etc.) DWORD BaseOfCode; // The RVA is the base address of the code section loaded in memory DWORD BaseOfData; // The RVA for the base address of the data section DWORD ImageBase; // This indicates the prefered address at which the file is intended to be loaded in memory, almost never used address instead the PE Loader looks for unused memory space to load the image. DWORD SectionAlignment; // Sections are aligned in memory boundaries that are multiples of this value DWORD FileAlignment; // Raw data alignment on disk WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; // Reserved (for future use) must be 0, ensures that the file is compatible with the current system DWORD SizeOfImage; // It gets rounded to a multiple of `SectionAlignment` DWORD SizeOfHeaders; // Sum(DOS Stub, NT Headers, Section Headers) DWORD CheckSum; // Checksum of the Image WORD Subsystem; // Refer to documentation for this one WORD DllCharacteristics; // Refer to documentation for this one DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; // Obsolete refering to documentation, 0 DWORD NumberOfRvaAndSizes; // Size of DataDirectory below IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // This contains the addresses of the Export/Import Directories, the Base Relocation table and so on. It is a constant of `16`. } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; I’ve written some quick comments on each of the fields however since that struct is lengthy and well documented you can check the fields here as well.\nHere is the the list of Data Directories entries:\n#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor Sections Headers The section headers are stored in the NT Headers. And the structure of the IMAGE_SECTION_HEADER looks like this:\ntypedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Source and Documentation PE Format The sections of a Portable Executable (PE) file contain various types of data, such as code, data, resources, and other information. The headers of the file are used to specify the characteristics of these sections, such as whether they contain executable code, initialized data, uninitialized data, or other types of information.\nTip: You can detect if a PE file has been packed by comparing the values of the VirtualSize and SizeOfRawData fields in the headers. If the VirtualSize is significantly larger than the SizeOfRawData, it is a strong indication that the file has been packed. However, it is worth noting that there may be some discrepancy between the two values due to section padding and alignment.\nSections Sections are where the actual data of the file is. There are Special Sections as well but we will focus only on the reserved sections such as:\n.bss - Uninitialized data (free format) .data - Initialized data (free format) .cormeta - CLR metadata that indicates that the object file contains managed code .debug (following with) $F - Generated FPO Frame Poiner Omission debug information (obsolete) $P - Precompiled debug types (object only) $S - Debug symbols (object only) $T - Debug types (object only) .drective - Linker Options .edata/.idata - Export/Import Tables .idlsym - Includes registered SEH (image only) to support IDL attributes. Often used in conjuction with FPO ref .pdata - Exception information .rdata - Read-only initialized data .reloc - Relocations of the Image .rsrc - Resource Directory .s(following with) - Global Pointer-relative .sbss - uninitialized data .sdata - initialized data .srdata - read-only data .sxdata - Registered exception handler data (free format and x86/object only) .vsdata - initialized data (free format and for ARM, SH4, and Thumb architectures only) .text - Executable code (free format) .tls/.tls$ - Thread-local storage (object only) .xdata - Exception information (free format) Refer to the documentation for further explanation. Each section is explained very well there.\nImport Directory Table (IDT) The Import Directory Table (IDT) stores information about dynamic-link libraries (DLLs) that a Portable Executable (PE) file depends on and the functions that the file imports from those DLLs. In most cases, this information is stored in the .idata section of the PE file, which is dedicated to this purpose. However, in some cases, the IDT may be stored elsewhere.\nThe address of the IDT can be found in the IMAGE_DATA_DIRECTORY array of the _IMAGE_OPTIONAL_HEADER structure. It is the second entry in the array. Each entry in the IDT is 8 bytes in size, with the first 4 bytes representing the address of the entry and the second 4 bytes representing the size. This information is used by the operating system’s dynamic linker to resolve the addresses of the imported functions and link them to the actual functions in the imported DLLs.\nLet’s take a look at an example:\nCC280000 The IDT is located at 0xCC28 A0000000 The size is 160 (A0) Following the address of the Import Directory we reach the first import located at 0xCC28, let’s see what is located at that address.\nEach Import is defined by 24 bytes, given these 24 bytes values:\nF8290000 OriginalFirstThunk 00000000 Timestamp 00000000 Forwarder Chain (Address) C02A0000 Name of the Import (RVA) D8210000 FirstThunk OriginalFirstThunk/FirstThunk To find out which functions are imported by a particular import in a Portable Executable (PE) file, we can follow the OriginalFirstThunk address at 0xF829, which leads us to the Import Lookup Table (ILT). The ILT is a sequence of bytes that represents the addresses of the imported functions, similar to an array or table.\nNote: It’s important to note that the Import Address Table (IAT) may be the same as the ILT. However, when a file is loaded, the loader will overwrite the addresses in the IAT with the new memory addresses of the imported functions.\nEach function address in the ILT is 8 bytes in length, so the resulting data should look something like this:\nFC2A0000 This is the address of the imported function 00000000 at 0xFC2A -\u003e B001 Ordinal/Name Import Flag 5368656C6C4578656375746557 ASCII -\u003e 'ShellExecuteW' 00 Null char terminating the string With this we can denote and ‘parse’ all the imports and respectively their imported functions.\nResources To locate the resources in a Portable Executable (PE) file, you can use the third entry in the IMAGE_DATA_DIRECTORY array of the IMAGE_OPTIONAL_HEADER structure. This entry contains the address and size of the resources section in the file.\n00000000 Characteristics 00000000 TimeDateStamp 0000 Major Version 0000 Minor Version 0000 Number of Named entities 0400 Number of ID entities And the corresponding struct\ntypedef struct _IMAGE_RESOURCE_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; WORD NumberOfNamedEntries; WORD NumberOfIdEntries; IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; } Now let’s take a look at the entries IMAGE_RESOURCE_DIRECTORY_ENTRY\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY { union { struct { DWORD NameOffset:31; DWORD NameIsString:1; } DUMMYSTRUCTNAME; DWORD Name; WORD Id; } DUMMYUNIONNAME; union { DWORD OffsetToData; // Leads us to the resource directory struct { DWORD OffsetToDirectory:31; DWORD DataIsDirectory:1; } DUMMYSTRUCTNAME2; } DUMMYUNIONNAME2; } IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY; The user mmn3mm has written a pretty good explanation of how to parse this section here.\nException Directory The Exception Directory is a section in a Portable Executable (PE) file that contains information about the exception handling functions in the code. It includes the addresses of the exception handling functions, the types of exceptions they handle, and other relevant details.\nWhen an exception occurs, the operating system’s exception handling mechanism uses the Exception Directory to find the appropriate exception handling function. This section is optional and may not be present in every PE file, depending on whether the code in the file uses exception handling.\nIt is typically located at .pdata section, and the offset to the Exception section is the 4th entry in the IMAGE_DATA_DIRECTORY array.\nPersonal Note: As far as I understood that section (I could be wrong here) it contains exception handlers that are being used throughout the execution and they execute only if the execution is within the specified BeginAddress and EndAddress.\nThe entries there are 12 bytes, first 4 bytes contains the BeginAddress the next 4 bytes contain the EndAddress and the last 4 bytes contains the address (UnwindInfoAddress) for the Unwind Information Block which contains information of how to unwind the stack whenever an exception occurs.\nBase Relocations When a program is compiled, the compiler saves a value into the IMAGE_OPTIONAL_HEADER.ImageBase field, which specifies the desired memory location where the program is intended to be executed. However, this memory location is often already occupied by other programs, so the actual memory location used by the program may be different. In this case, the loader will recalculate the ImageBase value and write the new value into the program’s image. This will cause all addresses in the program that are offset by the ImageBase value (essentially, all addresses in the program) to be recalculated with the new ImageBase value and stored in the .reloc section of the image. This process is necessary to ensure that the program can run correctly at its actual memory location.\nThe user 0xRick has written a very good article of how to calcuate the entries within the Relocation Block and more.\nDebug Microsoft Documentation\nThe Debug section is the 7th entry of the IMAGE_DATA_DIRECTORY array, its structure looks like this:\ntypedef struct _IMAGE_DEBUG_DIRECTORY { DWORD Characteristics; // Describing the debug info DWORD TimeDateStamp; WORD MajorVersion; // Version of the debugging tool WORD MinorVersion; // Version of the debugging tool DWORD Type; // Type of Debugging (this will denote the format that you need to parse) DWORD SizeOfData; // The size of the debug data (not including the debug directory itself) DWORD AddressOfRawData; // The address of the debug data when loaded, relative to the image base DWORD PointerToRawData; // The file pointer to the debug data. } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY; Refer to the Microsoft’s Documentation about how to parse further debug information.\nLoad Config This section contains information about the dynamic linking and loading of the executable or library and it is the 11th entry of the IMAGE_DATA_DIRECTORY array. The Load Config section typically includes information such as the address of the entry point of the program, the size of the stack and heap, and the addresses of any imported functions or data.\nIt can also include security and integrity-related information, such as Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR) settings.\nIt is typically located at .rdata section and it is an optional section for a PE file.\nThe structure follows:\ntypedef struct _IMAGE_LOAD_CONFIG_DIRECTORY { DWORD Size; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD GlobalFlagsClear; DWORD GlobalFlagsSet; DWORD CriticalSectionDefaultTimeout; DWORD DeCommitFreeBlockThreshold; DWORD DeCommitTotalFreeThreshold; PVOID LockPrefixTable; DWORD MaximumAllocationSize; DWORD VirtualMemoryThreshold; DWORD ProcessAffinityMask; DWORD ProcessHeapFlags; WORD CSDVersion; WORD DependentLoadFlags; PVOID EditList; PVOID SecurityCookie; PVOID SEHandlerTable; DWORD SEHandlerCount; PVOID GuardCFCheckFunctionPointer; PVOID GuardCFDispatchFunctionPointer; PVOID GuardCFFunctionTable; DWORD GuardCFFunctionCount; DWORD GuardFlags; } IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY; Access Rights of the Sections The section rights are presented in the DWORD Characteristics; field of the _IMAGE_SECTION_HEADER , you can check the valid values in the microsoft’s documentation.\nThose are the standard access rights of PE.\nSection Name Access Rights .text Read and Execute .rdata Read-Only .data Read and Write .bss Read and Write .rsrc Read Only .reloc Read Only Note: Seungwon Lee has indicated that if an essential element of an executable is the WRITE property of a section, the PE could be packed.\nConclusion This is the first part of my research on static analysis; the primary focus would be on Windows PEs and exactly how much information I can extract before going into the guessing territory.\nIn order for me to do that, I must know how do these files look like and what raw information is stored in their contents; that is why I started this research by examining Windows’s PE files.\nI hope you have reached that far and the information that I have provided is useful for you!\nReferences https://chat.openai.com/ https://github.com/mandiant/flare-floss https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings https://stackoverflow.com/questions/36550038/in-utf-16-utf-16be-utf-16le-is-the-endian-of-utf-16-the-computers-endianness https://0xrick.github.io/ https://securelist.com/the-devils-in-the-rich-header/84348/ https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/ https://forensicitguy.github.io/rich-header-hashes-with-pefile/ https://github.com/mmn3mm/peresources The Study of Evasion of Packed PE from Static Detection (Mirza Baig, Pavol Zavarsky, Ron Ruhl, Dale Lindskog) Han, Seungwon Lee, Keungi Lee, Sangjin, “Packed PE File Detection for Malware Forensics”, Computer Science and its Applications, 2nd International Conference, http://ieeexplore.ieee.org/stamp/stamp.jsp?arn umber=05404211, 12 Dec 2009 ","wordCount":"3168","inLanguage":"en","datePublished":"2023-01-06T09:44:47+03:00","dateModified":"2023-01-06T09:44:47+03:00","author":{"@type":"Person","name":"Dimitar Ganev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sy1.sh/posts/static-analysis-research-p1/"},"publisher":{"@type":"Organization","name":"0x73796C31","logo":{"@type":"ImageObject","url":"https://sy1.sh/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sy1.sh accesskey=h title="0x73796C31 (Alt + H)">0x73796C31</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sy1.sh/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://sy1.sh/cv title=CV><span>CV</span></a></li><li><a href=https://sy1.sh/writeups/ title=Write-ups><span>Write-ups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sy1.sh>Home</a>&nbsp;»&nbsp;<a href=https://sy1.sh/posts/>Posts</a></div><h1 class=post-title>Static Analysis Research - Windows PE</h1><div class=post-meta><span title='2023-01-06 09:44:47 +0300 +0300'>2023-01-06</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Dimitar Ganev</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#overview aria-label=Overview>Overview</a><ul><li><a href=#keywords aria-label=Keywords>Keywords</a></li></ul></li><li><a href=#windows-portable-executable-pe aria-label="Windows Portable Executable (PE)">Windows Portable Executable (PE)</a><ul><li><a href=#dos-header aria-label="DOS Header">DOS Header</a></li><li><a href=#dos-stub--rich-header aria-label="DOS Stub / Rich Header">DOS Stub / Rich Header</a></li><li><a href=#nt-headers-new-technology aria-label="NT Headers (New Technology)">NT Headers (New Technology)</a></li><li><a href=#sections-headers aria-label="Sections Headers">Sections Headers</a></li><li><a href=#sections aria-label=Sections>Sections</a></li><li><a href=#import-directory-table-idt aria-label="Import Directory Table (IDT)">Import Directory Table (IDT)</a></li><li><a href=#resources aria-label=Resources>Resources</a></li><li><a href=#exception-directory aria-label="Exception Directory">Exception Directory</a></li><li><a href=#base-relocations aria-label="Base Relocations">Base Relocations</a></li><li><a href=#debug aria-label=Debug>Debug</a></li><li><a href=#load-config aria-label="Load Config">Load Config</a></li><li><a href=#access-rights-of-the-sections aria-label="Access Rights of the Sections">Access Rights of the Sections</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p>Recently, I decided do delve a little bit more into static analysis, something beyond just running <code>strings</code> on a binary and getting the ASCII characters that are printable. I decided to take a deep look at how <a href=https://github.com/mandiant/flare-floss>FLOSS</a> is working and possibly recreate some of its functionality in my own tool.</p><p>Before reading further, I want you to know that this post is about research I did on static analysis. There is nothing new here - no new tools or features are being discovered. Everything that I talk about already exists in other tools. A big part of this research uses the OpenAI Chat GPT. I made sure to fact-check the information provided here, as the GPT can sometimes produce misleading output.</p><p>My research focuses on <a href="https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/winpe-intro?view=windows-11">Windows Portable Executable (PE)</a> files because they are the most common type. Therefore, we&rsquo;ll start by exploring how these files operate.</p><h2 id=keywords>Keywords<a hidden class=anchor aria-hidden=true href=#keywords>#</a></h2><ul><li><strong>RVA</strong> (Relative Virtual Address) - the virtual address of an object from the file once it is loaded into memory, minus the base address of the file image.</li><li><strong>IDT</strong> (Import Directory Table) - is a data structure in a Portable Executable (PE) file that stores information about dynamic-link libraries (DLLs) that the file depends on and the functions that the file imports from those DLLs.</li><li><strong>ILT</strong> - is a data structure in a Portable Executable (PE) file that stores the addresses of imported functions in the executable or library.</li><li><strong>IAT</strong> (Import Address Table) - can be the same with <strong>ILT</strong>, however when a file is being loaded into memory the loader will overwrite the addresses of the <strong>IAT</strong> with their new memory address locations.</li><li><strong>DEP</strong> (Data Execution Prevention) - is a security feature that is designed to prevent code from being executed in certain areas of memory where it is not supposed to be executed. <a href=https://learn.microsoft.com/en-us/windows/win32/memory/data-execution-prevention>doc</a></li><li><strong>ASLR</strong> (Address Space Layout Randomization) - is a security feature that randomizes the memory locations of certain parts of a program or operating system, making it more difficult for attackers to predict or control where certain code or data is located in memory. <a href=https://en.wikipedia.org/wiki/Address_space_layout_randomization>wiki</a></li></ul><h1 id=windows-portable-executable-pe>Windows Portable Executable (PE)<a hidden class=anchor aria-hidden=true href=#windows-portable-executable-pe>#</a></h1><p>An executable is a set of binary data that contains instructions for the operating system to execute when the program is loaded into memory. Let&rsquo;s examine how we can manually parse a Portable Executable (PE) file by reading and interpreting the bytes it contains. To do this, we must carefully review the binary data in the PE file and try to make sense of it.</p><blockquote><p>The term <strong>image</strong> refers to the contents of a file when it is loaded into memory. You will encounter this term frequently in the explanations below.</p></blockquote><h2 id=dos-header>DOS Header<a hidden class=anchor aria-hidden=true href=#dos-header>#</a></h2><p>The first 64 bytes of a binary file represent the DOS header, which is included for backwards compatibility and does not directly affect the functioning of the Portable Executable (PE). These 64 bytes contain information such as the number of pages in the file, the number of relocations, the checksum, OEM identifiers, and reserved words. The last 4 bytes of the DOS header, <code>e_lfanew</code>, contain the offset or address of the new PE header in modern Windows applications.</p><p>The first two bytes of an executable file, <code>4D 5A</code> which translates to <code>MZ</code> in ASCII, serve as an indicator that the file is an executable intended for use on a Windows operating system.</p><ul><li><a href=http://4d5asecurity.com/why-4d5a>Why <code>4D 5A</code>?</a></li></ul><h2 id=dos-stub--rich-header>DOS Stub / Rich Header<a hidden class=anchor aria-hidden=true href=#dos-stub--rich-header>#</a></h2><p>Following the first 64 bytes is the DOS Stub, a small program that displays an error message on systems that are not compatible with MS-DOS. This is a legacy feature dating back to the early days of Windows, when the operating system was built on top of MS-DOS.</p><p>The Rich Header, on the other hand, is not a required or standard part of the Portable Executable (PE) file format. It contains metadata about the compiler or packer that was used to create the executable and may provide additional information about the file. The magic number for the Rich Header is <code>52 69 63 68</code>, which translates to <code>Rich</code> in ASCII.</p><p>The Rich Header information is encrypted using the XOR cipher, which can be easily decrypted using the 4 bytes immediately following the Rich ASCII which is the key.</p><p>To decrypt the rest of the header, we must run the XOR decipher on the file and unmask the value <code>44 61 6E 53</code>, which translates to &ldquo;DanS&rdquo; in ASCII. This marks the beginning of the Rich Header, which is then followed by 3 <code>0s</code> after deciphering.</p><p>With this information, we can determine the start and end of the Rich Header and parse it accordingly.</p><p>The header can contain data about:</p><ul><li>Compiler and build environment information</li><li>Timestamps</li><li>Checksums</li><li>Other metadata</li></ul><p>The Rich Header is a very interesting topic that I would like to write more about, until then you can read the following articles.</p><ul><li><a href=https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/>VB2019 paper: Rich Headers: leveraging this mysterious artifact of the PE format</a></li><li><a href=https://securelist.com/the-devils-in-the-rich-header/84348/>The devil’s in the Rich header</a></li></ul><h2 id=nt-headers-new-technology>NT Headers (New Technology)<a hidden class=anchor aria-hidden=true href=#nt-headers-new-technology>#</a></h2><p>If we follow the offset indicated in the last two bytes of the DOS header, we will reach the new PE headers (also known as NT headers). These headers are identified by the 4-byte magic number <code>50 45 00 00</code>, which translates to <code>PE..</code> in ASCII. This magic number is used to distinguish the PE headers from other types of headers.</p><p>The structure of the <code>_IMAGE_NT_HEADERS64</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_NT_HEADERS64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>Signature</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_FILE_HEADER</span> <span class=n>FileHeader</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_OPTIONAL_HEADER64</span> <span class=n>OptionalHeader</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_NT_HEADERS64</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_NT_HEADERS64</span><span class=p>;</span>
</span></span></code></pre></div><p>The structure of <code>_IMAGE_FILE_HEADER</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_FILE_HEADER</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>  <span class=n>Machine</span><span class=p>;</span> <span class=c1>// Predefined value [IMAGE_FILE_MACHINE_I386 or IMAGE_FILE_MACHINE_AMD64]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WORD</span>  <span class=n>NumberOfSections</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>TimeDateStamp</span><span class=p>;</span> <span class=c1>// Timestamp of which the executable was compiled or linked
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>PointerToSymbolTable</span><span class=p>;</span> <span class=c1>// The offset to the COFF Symbol Table
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>NumberOfSymbols</span><span class=p>;</span> <span class=c1>// The number of symbols in the COFF Header
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WORD</span>  <span class=n>SizeOfOptionalHeader</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>  <span class=n>Characteristics</span><span class=p>;</span> <span class=c1>// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>IMAGE_FILE_HEADER</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_FILE_HEADER</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><a href=https://en.wikipedia.org/wiki/COFF>What is COFF?</a></li></ul><p>The structure of <code>_IMAGE_OPTIONAL_HEADER</code>, this structure is &ldquo;optional&rdquo; but in fact most of the PE files contains this header.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_OPTIONAL_HEADER</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>                 <span class=n>Magic</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                 <span class=n>MajorLinkerVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                 <span class=n>MinorLinkerVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>SizeOfCode</span><span class=p>;</span> <span class=c1>// .text section size
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>SizeOfInitializedData</span><span class=p>;</span> <span class=c1>// .data section size
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>SizeOfUninitializedData</span><span class=p>;</span> <span class=c1>// .bss section size 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>AddressOfEntryPoint</span><span class=p>;</span> <span class=c1>// 0 if a DLL because its optional otherwise it indicates the RVA (Relative Virtual Address) it is used to determine the address of elements within the file (strings, icons etc.)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>BaseOfCode</span><span class=p>;</span> <span class=c1>// The RVA is the base address of the code section loaded in memory
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>BaseOfData</span><span class=p>;</span> <span class=c1>// The RVA for the base address of the data section
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>ImageBase</span><span class=p>;</span> <span class=c1>// This indicates the prefered address at which the file is intended to be loaded in memory, almost never used address instead the PE Loader looks for unused memory space to load the image.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>SectionAlignment</span><span class=p>;</span> <span class=c1>// Sections are aligned in memory boundaries that are multiples of this value
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>FileAlignment</span><span class=p>;</span> <span class=c1>// Raw data alignment on disk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WORD</span>                 <span class=n>MajorOperatingSystemVersion</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>                 <span class=n>MinorOperatingSystemVersion</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>                 <span class=n>MajorImageVersion</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>                 <span class=n>MinorImageVersion</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>                 <span class=n>MajorSubsystemVersion</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>                 <span class=n>MinorSubsystemVersion</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>Win32VersionValue</span><span class=p>;</span> <span class=c1>// Reserved (for future use) must be 0, ensures that the file is compatible with the current system
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>SizeOfImage</span><span class=p>;</span> <span class=c1>// It gets rounded to a multiple of `SectionAlignment`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>SizeOfHeaders</span><span class=p>;</span> <span class=c1>// Sum(DOS Stub, NT Headers, Section Headers)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>CheckSum</span><span class=p>;</span> <span class=c1>// Checksum of the Image
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WORD</span>                 <span class=n>Subsystem</span><span class=p>;</span> <span class=c1>// Refer to documentation for this one
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WORD</span>                 <span class=n>DllCharacteristics</span><span class=p>;</span> <span class=c1>// Refer to documentation for this one
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>SizeOfStackReserve</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>SizeOfStackCommit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>SizeOfHeapReserve</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>SizeOfHeapCommit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>LoaderFlags</span><span class=p>;</span> <span class=c1>// Obsolete refering to documentation, 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span>                <span class=n>NumberOfRvaAndSizes</span><span class=p>;</span> <span class=c1>// Size of DataDirectory below
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>IMAGE_DATA_DIRECTORY</span> <span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span><span class=p>];</span> <span class=c1>// This contains the addresses of the Export/Import Directories, the Base Relocation table and so on. It is a constant of `16`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>IMAGE_OPTIONAL_HEADER32</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_OPTIONAL_HEADER32</span><span class=p>;</span>
</span></span></code></pre></div><p>I&rsquo;ve written some quick comments on each of the fields however since that struct is lengthy and well documented you can check the <a href=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32>fields here</a> as well.</p><p>Here is the the list of Data Directories entries:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   </span><span class=c1>// Export Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   </span><span class=c1>// Import Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   </span><span class=c1>// Resource Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   </span><span class=c1>// Exception Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   </span><span class=c1>// Security Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   </span><span class=c1>// Base Relocation Table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   </span><span class=c1>// Debug Directory
</span></span></span><span class=line><span class=cl><span class=c1>//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   </span><span class=c1>// Architecture Specific Data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   </span><span class=c1>// RVA of GP
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_TLS             9   </span><span class=c1>// TLS Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   </span><span class=c1>// Load Configuration Directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   </span><span class=c1>// Bound Import Directory in headers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_IAT            12   </span><span class=c1>// Import Address Table
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   </span><span class=c1>// Delay Load Import Descriptors
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   </span><span class=c1>// COM Runtime descriptor
</span></span></span></code></pre></div><h2 id=sections-headers>Sections Headers<a hidden class=anchor aria-hidden=true href=#sections-headers>#</a></h2><p>The section headers are stored in the NT Headers. And the structure of the <code>IMAGE_SECTION_HEADER</code> looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_SECTION_HEADER</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>  <span class=n>Name</span><span class=p>[</span><span class=n>IMAGE_SIZEOF_SHORT_NAME</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>PhysicalAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>VirtualSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>Misc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>VirtualAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>SizeOfRawData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>PointerToRawData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>PointerToRelocations</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>PointerToLinenumbers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>  <span class=n>NumberOfRelocations</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>  <span class=n>NumberOfLinenumbers</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>Characteristics</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_SECTION_HEADER</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_SECTION_HEADER</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><a href=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header>Source and Documentation</a></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-table-section-headers>PE Format</a></li></ul><p>The sections of a Portable Executable (PE) file contain various types of data, such as code, data, resources, and other information. The headers of the file are used to specify the characteristics of these sections, such as whether they contain executable code, initialized data, uninitialized data, or other types of information.</p><blockquote><p><strong>Tip</strong>: You can detect if a PE file has been packed by comparing the values of the <code>VirtualSize</code> and <code>SizeOfRawData</code> fields in the headers. If the <code>VirtualSize</code> is significantly larger than the <code>SizeOfRawData</code>, it is a strong indication that the file has been packed. However, it is worth noting that there may be some discrepancy between the two values due to section padding and alignment.</p></blockquote><h2 id=sections>Sections<a hidden class=anchor aria-hidden=true href=#sections>#</a></h2><p>Sections are where the actual data of the file is. There are <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#special-sections>Special Sections</a> as well but we will focus only on the reserved sections such as:</p><ul><li>.bss - Uninitialized data (free format)</li><li>.data - Initialized data (free format)</li><li>.cormeta - CLR metadata that indicates that the object file contains managed code</li><li>.debug (following with)<ul><li>$F - Generated FPO <a href="http://www.nynaeve.net/?p=91">Frame Poiner Omission</a> debug information (obsolete)</li><li>$P - Precompiled debug types (object only)</li><li>$S - Debug symbols (object only)</li><li>$T - Debug types (object only)</li></ul></li><li>.drective - Linker Options</li><li>.edata/.idata - Export/Import Tables</li><li>.idlsym - Includes registered SEH (image only) to support IDL attributes. Often used in conjuction with FPO <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#references>ref</a></li><li>.pdata - Exception information</li><li>.rdata - Read-only initialized data</li><li>.reloc - Relocations of the Image</li><li>.rsrc - Resource Directory</li><li>.s(following with) - Global Pointer-relative<ul><li>.sbss - uninitialized data</li><li>.sdata - initialized data</li><li>.srdata - read-only data</li><li>.sxdata - Registered exception handler data (free format and x86/object only)</li><li>.vsdata - initialized data (free format and for ARM, SH4, and Thumb architectures only)</li></ul></li><li>.text - Executable code (free format)</li><li>.tls/.tls$ - Thread-local storage (object only)</li><li>.xdata - Exception information (free format)</li></ul><p>Refer to the <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#special-sections>documentation</a> for further explanation. Each section is explained very well there.</p><h2 id=import-directory-table-idt>Import Directory Table (IDT)<a hidden class=anchor aria-hidden=true href=#import-directory-table-idt>#</a></h2><p>The Import Directory Table (<strong>IDT</strong>) stores information about dynamic-link libraries (DLLs) that a Portable Executable (PE) file depends on and the functions that the file imports from those DLLs. In most cases, this information is stored in the <code>.idata</code> section of the PE file, which is dedicated to this purpose. However, in some cases, the <strong>IDT</strong> may be stored elsewhere.</p><p>The address of the IDT can be found in the <code>IMAGE_DATA_DIRECTORY</code> array of the <code>_IMAGE_OPTIONAL_HEADER</code> structure. It is the second entry in the array. Each entry in the IDT is 8 bytes in size, with the first 4 bytes representing the address of the entry and the second 4 bytes representing the size. This information is used by the operating system&rsquo;s dynamic linker to resolve the addresses of the imported functions and link them to the actual functions in the imported DLLs.</p><p>Let&rsquo;s take a look at an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>CC280000 
</span></span><span class=line><span class=cl>	The IDT is located at 0xCC28
</span></span><span class=line><span class=cl>A0000000
</span></span><span class=line><span class=cl>	The size is 160 (A0)
</span></span></code></pre></div><p>Following the address of the Import Directory we reach the first import located at <code>0xCC28</code>, let&rsquo;s see what is located at that address.</p><p>Each Import is defined by 24 bytes, given these 24 bytes values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>F8290000
</span></span><span class=line><span class=cl>	OriginalFirstThunk
</span></span><span class=line><span class=cl>00000000
</span></span><span class=line><span class=cl>	Timestamp
</span></span><span class=line><span class=cl>00000000
</span></span><span class=line><span class=cl>	Forwarder Chain (Address)
</span></span><span class=line><span class=cl>C02A0000
</span></span><span class=line><span class=cl>	Name of the Import (RVA)
</span></span><span class=line><span class=cl>D8210000
</span></span><span class=line><span class=cl>	FirstThunk
</span></span></code></pre></div><ul><li><a href=https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft>OriginalFirstThunk/FirstThunk</a></li></ul><p>To find out which functions are imported by a particular import in a Portable Executable (PE) file, we can follow the <code>OriginalFirstThunk</code> address at <code>0xF829</code>, which leads us to the Import Lookup Table (ILT). The ILT is a sequence of bytes that represents the addresses of the imported functions, similar to an array or table.</p><blockquote><p><strong>Note</strong>: It&rsquo;s important to note that the Import Address Table (IAT) may be the same as the ILT. However, when a file is loaded, the loader will overwrite the addresses in the IAT with the new memory addresses of the imported functions.</p></blockquote><p>Each function address in the ILT is 8 bytes in length, so the resulting data should look something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>FC2A0000
</span></span><span class=line><span class=cl>    This is the address of the imported function
</span></span><span class=line><span class=cl>00000000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>at 0xFC2A -&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>B001
</span></span><span class=line><span class=cl>	Ordinal/Name Import Flag
</span></span><span class=line><span class=cl>5368656C6C4578656375746557
</span></span><span class=line><span class=cl>	ASCII -&gt; &#39;ShellExecuteW&#39;
</span></span><span class=line><span class=cl>00
</span></span><span class=line><span class=cl>	Null char terminating the string
</span></span></code></pre></div><p>With this we can denote and &lsquo;parse&rsquo; all the imports and respectively their imported functions.</p><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><p>To locate the resources in a Portable Executable (PE) file, you can use the third entry in the <code>IMAGE_DATA_DIRECTORY</code> array of the <code>IMAGE_OPTIONAL_HEADER</code> structure. This entry contains the address and size of the resources section in the file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>00000000 
</span></span><span class=line><span class=cl>	Characteristics
</span></span><span class=line><span class=cl>00000000
</span></span><span class=line><span class=cl>	TimeDateStamp
</span></span><span class=line><span class=cl>0000
</span></span><span class=line><span class=cl>	Major Version
</span></span><span class=line><span class=cl>0000
</span></span><span class=line><span class=cl>	Minor Version
</span></span><span class=line><span class=cl>0000
</span></span><span class=line><span class=cl>	Number of Named entities
</span></span><span class=line><span class=cl>0400
</span></span><span class=line><span class=cl>	Number of ID entities
</span></span></code></pre></div><p>And the corresponding struct</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_RESOURCE_DIRECTORY</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>DWORD</span>   <span class=n>Characteristics</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>DWORD</span>   <span class=n>TimeDateStamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>WORD</span>    <span class=n>MajorVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>WORD</span>    <span class=n>MinorVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>WORD</span>    <span class=n>NumberOfNamedEntries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=n>WORD</span>    <span class=n>NumberOfIdEntries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>IMAGE_RESOURCE_DIRECTORY_ENTRY</span> <span class=n>DirectoryEntries</span><span class=p>[];</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span></code></pre></div><p>Now let&rsquo;s take a look at the entries <code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_RESOURCE_DIRECTORY_ENTRY</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>DWORD</span> <span class=nl>NameOffset</span><span class=p>:</span><span class=mi>31</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>DWORD</span> <span class=nl>NameIsString</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>DUMMYSTRUCTNAME</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>Name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>Id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>DUMMYUNIONNAME</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>OffsetToData</span><span class=p>;</span> <span class=c1>// Leads us to the resource directory 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>DWORD</span>   <span class=nl>OffsetToDirectory</span><span class=p>:</span><span class=mi>31</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>DWORD</span>   <span class=nl>DataIsDirectory</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>DUMMYSTRUCTNAME2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>DUMMYUNIONNAME2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_RESOURCE_DIRECTORY_ENTRY</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_RESOURCE_DIRECTORY_ENTRY</span><span class=p>;</span>
</span></span></code></pre></div><p>The user <code>mmn3mm</code> has written a pretty good explanation of how to parse this section <a href=https://github.com/mmn3mm/peresources>here</a>.</p><h2 id=exception-directory>Exception Directory<a hidden class=anchor aria-hidden=true href=#exception-directory>#</a></h2><p>The Exception Directory is a section in a Portable Executable (PE) file that contains information about the exception handling functions in the code. It includes the addresses of the exception handling functions, the types of exceptions they handle, and other relevant details.</p><p>When an exception occurs, the operating system&rsquo;s exception handling mechanism uses the Exception Directory to find the appropriate exception handling function. This section is optional and may not be present in every PE file, depending on whether the code in the file uses exception handling.</p><p>It is typically located at <code>.pdata</code> section, and the offset to the Exception section is the 4th entry in the <code>IMAGE_DATA_DIRECTORY</code> array.</p><blockquote><p><strong>Personal Note</strong>: As far as I understood that section (I could be wrong here) it contains exception handlers that are being used throughout the execution and they execute only if the execution is within the specified <code>BeginAddress</code> and <code>EndAddress</code>.</p></blockquote><p>The entries there are 12 bytes, first 4 bytes contains the <code>BeginAddress</code> the next 4 bytes contain the <code>EndAddress</code> and the last 4 bytes contains the address (<code>UnwindInfoAddress</code>) for the <strong>Unwind Information Block</strong> which contains information of how to unwind the stack whenever an exception occurs.</p><h2 id=base-relocations>Base Relocations<a hidden class=anchor aria-hidden=true href=#base-relocations>#</a></h2><p>When a program is compiled, the compiler saves a value into the <code>IMAGE_OPTIONAL_HEADER.ImageBase</code> field, which specifies the desired memory location where the program is intended to be executed. However, this memory location is often already occupied by other programs, so the actual memory location used by the program may be different. In this case, the loader will recalculate the <code>ImageBase</code> value and write the new value into the program&rsquo;s image. This will cause all addresses in the program that are offset by the <code>ImageBase</code> value (essentially, all addresses in the program) to be recalculated with the new ImageBase value and stored in the <code>.reloc</code> section of the image. This process is necessary to ensure that the program can run correctly at its actual memory location.</p><p>The user <code>0xRick</code> has written a <a href=https://0xrick.github.io/win-internals/pe7/>very good article</a> of how to calcuate the entries within the Relocation Block and more.</p><h2 id=debug>Debug<a hidden class=anchor aria-hidden=true href=#debug>#</a></h2><p><a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#debug-directory-image-only>Microsoft Documentation</a></p><p>The Debug section is the 7th entry of the <code>IMAGE_DATA_DIRECTORY</code> array, its structure looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_DEBUG_DIRECTORY</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>Characteristics</span><span class=p>;</span> <span class=c1>// Describing the debug info
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span>   <span class=n>TimeDateStamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>MajorVersion</span><span class=p>;</span> <span class=c1>// Version of the debugging tool
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WORD</span>    <span class=n>MinorVersion</span><span class=p>;</span> <span class=c1>// Version of the debugging tool
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span>   <span class=n>Type</span><span class=p>;</span> <span class=c1>// Type of Debugging (this will denote the format that you need to parse)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span>   <span class=n>SizeOfData</span><span class=p>;</span> <span class=c1>// The size of the debug data (not including the debug directory itself)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span>   <span class=n>AddressOfRawData</span><span class=p>;</span> <span class=c1>// The address of the debug data when loaded, relative to the image base
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span>   <span class=n>PointerToRawData</span><span class=p>;</span> <span class=c1>// The file pointer to the debug data.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>IMAGE_DEBUG_DIRECTORY</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_DEBUG_DIRECTORY</span><span class=p>;</span>
</span></span></code></pre></div><p>Refer to the <a href=https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#debug-type>Microsoft&rsquo;s Documentation</a> about how to parse further debug information.</p><h2 id=load-config>Load Config<a hidden class=anchor aria-hidden=true href=#load-config>#</a></h2><p>This section contains information about the dynamic linking and loading of the executable or library and it is the 11th entry of the <code>IMAGE_DATA_DIRECTORY</code> array. The Load Config section typically includes information such as the address of the entry point of the program, the size of the stack and heap, and the addresses of any imported functions or data.</p><p>It can also include security and integrity-related information, such as Data Execution Prevention (<strong>DEP</strong>) and Address Space Layout Randomization (<strong>ASLR</strong>) settings.</p><p>It is typically located at <code>.rdata</code> section and it is an optional section for a PE file.</p><p>The structure follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_IMAGE_LOAD_CONFIG_DIRECTORY</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>Size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>TimeDateStamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>MajorVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>MinorVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>GlobalFlagsClear</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>GlobalFlagsSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>CriticalSectionDefaultTimeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>DeCommitFreeBlockThreshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>DeCommitTotalFreeThreshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>LockPrefixTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>MaximumAllocationSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>VirtualMemoryThreshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>ProcessAffinityMask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>ProcessHeapFlags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>CSDVersion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WORD</span>    <span class=n>DependentLoadFlags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>EditList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>SecurityCookie</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>SEHandlerTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>SEHandlerCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>GuardCFCheckFunctionPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>GuardCFDispatchFunctionPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PVOID</span>   <span class=n>GuardCFFunctionTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>GuardCFFunctionCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>   <span class=n>GuardFlags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>IMAGE_LOAD_CONFIG_DIRECTORY</span><span class=p>,</span> <span class=o>*</span><span class=n>PIMAGE_LOAD_CONFIG_DIRECTORY</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=access-rights-of-the-sections>Access Rights of the Sections<a hidden class=anchor aria-hidden=true href=#access-rights-of-the-sections>#</a></h2><p>The section rights are presented in the <code>DWORD Characteristics;</code> field of the <code>_IMAGE_SECTION_HEADER </code>, you can check the valid values in the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header?redirectedfrom=MSDN#members">microsoft&rsquo;s documentation</a>.</p><p>Those are the standard access rights of PE.</p><table><thead><tr><th>Section Name</th><th>Access Rights</th></tr></thead><tbody><tr><td><code>.text</code></td><td>Read and Execute</td></tr><tr><td><code>.rdata</code></td><td>Read-Only</td></tr><tr><td><code>.data</code></td><td>Read and Write</td></tr><tr><td><code>.bss</code></td><td>Read and Write</td></tr><tr><td><code>.rsrc</code></td><td>Read Only</td></tr><tr><td><code>.reloc</code></td><td>Read Only</td></tr></tbody></table><blockquote><p>Note: Seungwon Lee has indicated that if an essential element of an executable is the WRITE property of a section, the PE could be packed.</p></blockquote><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>This is the first part of my research on static analysis; the primary focus would be on Windows PEs and exactly how much information I can extract before going into the guessing territory.</p><p>In order for me to do that, I must know how do these files look like and what raw information is stored in their contents; that is why I started this research by examining Windows&rsquo;s PE files.</p><p>I hope you have reached that far and the information that I have provided is useful for you!</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ul><li><a href=https://chat.openai.com/>https://chat.openai.com/</a></li><li><a href=https://github.com/mandiant/flare-floss>https://github.com/mandiant/flare-floss</a></li><li><a href=https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings>https://www.mandiant.com/resources/blog/automatically-extracting-obfuscated-strings</a></li><li><a href=https://stackoverflow.com/questions/36550038/in-utf-16-utf-16be-utf-16le-is-the-endian-of-utf-16-the-computers-endianness>https://stackoverflow.com/questions/36550038/in-utf-16-utf-16be-utf-16le-is-the-endian-of-utf-16-the-computers-endianness</a></li><li><a href=https://0xrick.github.io/>https://0xrick.github.io/</a></li><li><a href=https://securelist.com/the-devils-in-the-rich-header/84348/>https://securelist.com/the-devils-in-the-rich-header/84348/</a></li><li><a href=https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/>https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/</a></li><li><a href=https://forensicitguy.github.io/rich-header-hashes-with-pefile/>https://forensicitguy.github.io/rich-header-hashes-with-pefile/</a></li><li><a href=https://github.com/mmn3mm/peresources>https://github.com/mmn3mm/peresources</a></li><li>The Study of Evasion of Packed PE from Static Detection (Mirza Baig, Pavol Zavarsky, Ron Ruhl, Dale Lindskog)</li><li>Han, Seungwon Lee, Keungi Lee, Sangjin, “Packed PE File Detection for Malware Forensics”, Computer Science and its Applications, 2nd International Conference, <a href=http://ieeexplore.ieee.org/stamp/stamp.jsp?arn>http://ieeexplore.ieee.org/stamp/stamp.jsp?arn</a> umber=05404211, 12 Dec 2009</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://sy1.sh/posts/dns-c2-communcation/><span class=title>Next »</span><br><span>Using DNS as C2 Communication - Evasive Techniques (Part 3)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://sy1.sh>0x73796C31</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>